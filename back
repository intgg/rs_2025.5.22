import os

project_root = os.getcwd()

os.environ["FUNASR_CACHE"] = os.path.join(project_root, "models", "cached_models")
os.environ["HF_HOME"] = os.path.join(project_root, "models", "hf_cache")
os.environ["MODELSCOPE_CACHE"] = os.path.join(project_root, "models", "modelscope_cache")

import tkinter as tk
from tkinter import ttk, scrolledtext
import asyncio
import threading
import queue
import time # Added for sleep in worker threads on error
import sounddevice as sd # 添加 sounddevice
import pygame # 添加 pygame

# 尝试导入现有模块
try:
    from FunASR import FastLoadASR
    # Placeholder for FunASR modification: FunASR will need a way to callback/put results to this app
except ImportError:
    print("警告: FunASR.py 未找到或无法导入。语音识别功能将不可用。")
    FastLoadASR = None

try:
    from translation_module import TranslationModule, LANGUAGE_CODES, LANGUAGE_NAMES
    # TODO: Replace with your actual API keys for translation_module
    TRANSLATION_APP_ID = "86c79fb7"  # <--- 在此处替换您的 APPID
    TRANSLATION_API_SECRET = "MDY3ZGFkYWEyZDBiOTJkOGIyOTllOWMz" # <--- 在此处替换您的 API_SECRET
    TRANSLATION_API_KEY = "f4369644e37eddd43adfe436e7904cf1"   # <--- 在此处替换您的 API_KEY
except ImportError:
    print("警告: translation_module.py 未找到或无法导入。翻译功能将不可用。")
    TranslationModule = None
    LANGUAGE_CODES = {"中文": "cn", "英语": "en"} # Fallback
    LANGUAGE_NAMES = {"cn": "中文", "en": "英语"} # Fallback

try:
    import edge_TTS
    SUPPORTED_TTS_VOICES = edge_TTS.SUPPORTED_VOICES # Import the list
except ImportError:
    print("警告: edge_TTS.py 未找到或无法导入。语音合成功能将不可用。")
    edge_TTS = None
    SUPPORTED_TTS_VOICES = [] # Fallback

# --- Generate Combined Supported Languages ---
# This list will store dicts like: {'display_name': '英语', 'translation_code': 'en'}
COMBINED_SUPPORTED_LANGUAGES = []
if TranslationModule and LANGUAGE_CODES and SUPPORTED_TTS_VOICES:
    translation_display_to_code = LANGUAGE_CODES
    tts_supported_display_names = set(v["language_display"] for v in SUPPORTED_TTS_VOICES)

    for display_name, code in translation_display_to_code.items():
        # We need to handle cases where display names might slightly differ
        # For simplicity, we'll assume exact match for now, but this might need refinement
        # e.g., "中文" in translation vs "中文 (普通话)" in TTS.
        # For now, let's try a direct match and also check if a more specific TTS lang starts with the translation lang.
        if display_name in tts_supported_display_names:
            COMBINED_SUPPORTED_LANGUAGES.append({"display_name": display_name, "translation_code": code})
        else:
            # Attempt a broader match: e.g. "中文" (translation) and "中文" part of "中文 (普通话)" (TTS)
            # This is a simple attempt; more robust mapping might be needed if names diverge significantly.
            for tts_lang_display in tts_supported_display_names:
                if tts_lang_display.startswith(display_name):
                    COMBINED_SUPPORTED_LANGUAGES.append({"display_name": display_name, "translation_code": code})
                    break # Add once per translation language if a match is found
    # Remove duplicates that might arise from the above logic if display_name is identical
    temp_list = []
    seen_codes = set()
    for item in COMBINED_SUPPORTED_LANGUAGES:
        if item['translation_code'] not in seen_codes:
            temp_list.append(item)
            seen_codes.add(item['translation_code'])
    COMBINED_SUPPORTED_LANGUAGES = sorted(temp_list, key=lambda x: x['display_name'])

if not COMBINED_SUPPORTED_LANGUAGES and LANGUAGE_CODES: # Fallback if TTS voices are not available or no match
    print("警告: 未能从TTS模块加载语言或未找到共同支持的语言。将仅使用翻译模块的语言作为目标语言。")
    COMBINED_SUPPORTED_LANGUAGES = sorted(
        [{"display_name": name, "translation_code": code} for name, code in LANGUAGE_CODES.items()],
        key=lambda x: x['display_name']
    )

class SimultaneousTranslatorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("同声传译应用")
        self.root.geometry("800x750") # 稍微增加高度以容纳新控件

        self.is_running = False
        # self.asr_instance = None # Will be initialized below
        self.translation_instance = None
        self.selected_input_device_idx = None
        self.selected_output_device_name = None

        # 初始化 Pygame Mixer 标记
        self.mixer_initialized = False
        self.mixer_output_device_name = None # Initialize the attribute here

        # Initialize Translation Module
        if TranslationModule and TRANSLATION_APP_ID != "YOUR_APP_ID" and TRANSLATION_API_KEY != "YOUR_API_KEY" and TRANSLATION_API_SECRET != "YOUR_API_SECRET":
            self.translation_instance = TranslationModule(
                app_id=TRANSLATION_APP_ID,
                api_secret=TRANSLATION_API_SECRET,
                api_key=TRANSLATION_API_KEY
            )
        else:
            print("警告: 翻译模块API密钥未配置或模块导入失败。翻译功能将不可用。")
            if TRANSLATION_APP_ID == "YOUR_APP_ID":
                print("请在 simultaneous_translator_app.py 中设置 TRANSLATION_APP_ID, TRANSLATION_API_SECRET, 和 TRANSLATION_API_KEY")

        self.asr_output_queue = queue.Queue()
        self.translation_output_queue = queue.Queue()

        self.current_recognized_sentence = ""
        self.last_final_asr_text = ""
        self.recognized_text_has_interim = False

        # ASR activity timeout logic
        self.last_asr_activity_time = None
        self.force_sentence_end_timeout = 1.0  # Seconds
        self.asr_timeout_check_timer_id = None
        self.raw_text_of_last_forced_sentence = None # New: Store raw text of the last sentence that was force-finalized

        self.all_models_loaded = False # New: For model loading status

        # --- UI Elements ---
        control_frame = ttk.Frame(root, padding="10")
        control_frame.pack(fill=tk.X)

        # 设备选择框
        device_frame = ttk.Frame(control_frame)
        device_frame.pack(fill=tk.X, pady=(0, 5))

        ttk.Label(device_frame, text="输入设备:").pack(side=tk.LEFT, padx=(0,5))
        self.input_device_var = tk.StringVar()
        self.input_device_dropdown = ttk.Combobox(device_frame, textvariable=self.input_device_var, state="readonly", width=25)
        self.input_device_dropdown.pack(side=tk.LEFT, padx=(0,10))
        self.input_device_dropdown.bind("<<ComboboxSelected>>", self.on_input_device_selected)

        ttk.Label(device_frame, text="输出设备:").pack(side=tk.LEFT, padx=(0,5))
        self.output_device_var = tk.StringVar()
        self.output_device_dropdown = ttk.Combobox(device_frame, textvariable=self.output_device_var, state="readonly", width=25)
        self.output_device_dropdown.pack(side=tk.LEFT, padx=(0,10))
        self.output_device_dropdown.bind("<<ComboboxSelected>>", self.on_output_device_selected)

        lang_frame = ttk.Frame(control_frame)
        lang_frame.pack(fill=tk.X)

        ttk.Label(lang_frame, text="源语言:").pack(side=tk.LEFT, padx=(0,5))
        self.source_lang_var = tk.StringVar(value="中文 (FunASR)")
        ttk.Entry(lang_frame, textvariable=self.source_lang_var, state="readonly", width=15).pack(side=tk.LEFT, padx=(0,10))

        ttk.Label(lang_frame, text="目标语言:").pack(side=tk.LEFT, padx=(0,5))
        self.target_lang_var = tk.StringVar()
        self.target_lang_dropdown = ttk.Combobox(lang_frame, textvariable=self.target_lang_var, state="readonly", width=15) # Increased width
        self.target_lang_dropdown.pack(side=tk.LEFT, padx=(0,10))
        self.target_lang_dropdown.bind("<<ComboboxSelected>>", self.on_target_language_selected)

        ttk.Label(lang_frame, text="性别:").pack(side=tk.LEFT, padx=(0,5))
        self.gender_var = tk.StringVar()
        self.gender_dropdown = ttk.Combobox(lang_frame, textvariable=self.gender_var, state="readonly", width=8)
        self.gender_dropdown.pack(side=tk.LEFT, padx=(0,10))
        self.gender_dropdown.bind("<<ComboboxSelected>>", self.on_gender_selected)

        ttk.Label(lang_frame, text="音色:").pack(side=tk.LEFT, padx=(0,5))
        self.tts_voice_var = tk.StringVar() # This will store the short_name of the selected voice
        self.tts_voice_dropdown = ttk.Combobox(lang_frame, textvariable=self.tts_voice_var, state="readonly", width=30) # Adjusted width
        self.tts_voice_dropdown.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=(0,10))
        # No specific bind needed for tts_voice_dropdown if selection directly gives short_name

        # ASR Settings Frame
        asr_settings_frame = ttk.Frame(control_frame)
        asr_settings_frame.pack(fill=tk.X, pady=(5,0))

        ttk.Label(asr_settings_frame, text="ASR静音时长(s):").pack(side=tk.LEFT, padx=(0,5))
        self.asr_silence_duration_var = tk.DoubleVar(value=0.5) # Default changed to 0.5
        self.asr_silence_duration_scale = ttk.Scale(
            asr_settings_frame, from_=0.1, to=2.0, # Range can be kept or adjusted if needed
            variable=self.asr_silence_duration_var, orient=tk.HORIZONTAL,
            command=self._update_asr_duration_label
        )
        self.asr_silence_duration_scale.pack(side=tk.LEFT, padx=(0,5), fill=tk.X, expand=True)
        self.asr_silence_duration_label_var = tk.StringVar(value=f"{self.asr_silence_duration_var.get():.2f}s")
        ttk.Label(asr_settings_frame, textvariable=self.asr_silence_duration_label_var, width=6).pack(side=tk.LEFT, padx=(0,10))

        ttk.Label(asr_settings_frame, text="ASR相对静音阈值:").pack(side=tk.LEFT, padx=(0,5))
        self.asr_relative_silence_var = tk.DoubleVar(value=0.5) # Default changed to 0.5
        self.asr_relative_silence_scale = ttk.Scale(
            asr_settings_frame, from_=0.0, to=1.0, # Range changed to 0.0 - 1.0
            variable=self.asr_relative_silence_var, orient=tk.HORIZONTAL,
            command=self._update_asr_relative_vol_label
        )
        self.asr_relative_silence_scale.pack(side=tk.LEFT, padx=(0,5), fill=tk.X, expand=True)
        self.asr_relative_silence_label_var = tk.StringVar(value=f"{self.asr_relative_silence_var.get():.2f}")
        ttk.Label(asr_settings_frame, textvariable=self.asr_relative_silence_label_var, width=5).pack(side=tk.LEFT, padx=(0,10))

        # TTS Prosody Controls Frame
        prosody_frame = ttk.Frame(control_frame)
        prosody_frame.pack(fill=tk.X, pady=(5, 0))

        # Rate Scale
        ttk.Label(prosody_frame, text="语速:").pack(side=tk.LEFT, padx=(0,5))
        self.tts_rate_var = tk.DoubleVar(value=0) # Default rate: 0%
        self.tts_rate_scale = ttk.Scale(prosody_frame, from_=-100, to=100, variable=self.tts_rate_var, orient=tk.HORIZONTAL, command=self._update_rate_label)
        self.tts_rate_scale.pack(side=tk.LEFT, padx=(0,5), fill=tk.X, expand=True)
        self.tts_rate_label_var = tk.StringVar(value="0%")
        ttk.Label(prosody_frame, textvariable=self.tts_rate_label_var, width=5).pack(side=tk.LEFT, padx=(0,10))

        # Volume Scale
        ttk.Label(prosody_frame, text="音量:").pack(side=tk.LEFT, padx=(0,5))
        self.tts_volume_var = tk.DoubleVar(value=0) # Default volume: 0%
        self.tts_volume_scale = ttk.Scale(prosody_frame, from_=-100, to=100, variable=self.tts_volume_var, orient=tk.HORIZONTAL, command=self._update_volume_label)
        self.tts_volume_scale.pack(side=tk.LEFT, padx=(0,5), fill=tk.X, expand=True)
        self.tts_volume_label_var = tk.StringVar(value="0%")
        ttk.Label(prosody_frame, textvariable=self.tts_volume_label_var, width=5).pack(side=tk.LEFT, padx=(0,10))

        self.start_stop_button = ttk.Button(control_frame, text="开始同传", command=self.toggle_translation, width=12, state="disabled")
        self.start_stop_button.pack(side=tk.RIGHT, padx=(10,0))

        text_frame = ttk.Frame(root, padding="5")
        text_frame.pack(fill=tk.BOTH, expand=True)
        text_frame.columnconfigure(0, weight=1)
        text_frame.rowconfigure(1, weight=1)
        text_frame.rowconfigure(3, weight=1)
        text_frame.rowconfigure(5, weight=1)

        ttk.Label(text_frame, text="识别结果 (源语言):").grid(row=0, column=0, sticky=tk.W, padx=5, pady=(5,0))
        self.recognized_text_area = scrolledtext.ScrolledText(text_frame, height=8, wrap=tk.WORD, state="disabled")
        self.recognized_text_area.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0,5))

        ttk.Label(text_frame, text="翻译结果 (目标语言):").grid(row=2, column=0, sticky=tk.W, padx=5, pady=(5,0))
        self.translated_text_area = scrolledtext.ScrolledText(text_frame, height=8, wrap=tk.WORD, state="disabled")
        self.translated_text_area.grid(row=3, column=0, sticky="nsew", padx=5, pady=(0,5))

        ttk.Label(text_frame, text="日志与状态:").grid(row=4, column=0, sticky=tk.W, padx=5, pady=(10,0))
        self.log_text_area = scrolledtext.ScrolledText(text_frame, height=6, wrap=tk.WORD, state="disabled")
        self.log_text_area.grid(row=5, column=0, sticky="nsew", padx=5, pady=(0,5))
        # --- End of UI Elements from previous version ---

        self.async_loop_thread = None
        self.async_loop = None
        if edge_TTS:
            self.start_asyncio_loop()

        self.populate_audio_devices() # 填充音频设备列表
        self.populate_unified_target_languages() # Changed from populate_target_languages
        self.root.after(100, self.process_ui_updates)
        self.log_message("应用已初始化。")

        # Bind the new on_tts_voice_selected callback to the tts_voice_dropdown
        # This ensures that when a user selects a voice from the dropdown, self.tts_voice_var is updated with the short_name
        self.tts_voice_dropdown.bind("<<ComboboxSelected>>", self.on_tts_voice_selected)

        # Initialize ASR Instance and load models once
        self.asr_instance = None
        if FastLoadASR:
            self.log_message("正在初始化 FunASR 实例...")
            try:
                self.asr_instance = FastLoadASR(
                    use_vad=True,
                    use_punc=True,
                    text_output_callback=self.asr_text_callback,
                    input_device_index=self.selected_input_device_idx # 使用选择的输入设备
                    # Add max_speech_segment_duration_seconds if we implement it in FunASR
                )
                if self.asr_instance: # 新增：确保实例存在
                    try:
                        # 从UI控件获取初始值
                        initial_duration = self.asr_silence_duration_var.get()
                        initial_relative_vol = self.asr_relative_silence_var.get()
                        self.asr_instance.silence_duration_threshold = initial_duration
                        self.asr_instance.relative_silence_threshold = initial_relative_vol
                        self.log_message(f"FunASR静音参数已初始化: Duration={initial_duration:.2f}s, RelativeVol={initial_relative_vol:.2f}")
                    except AttributeError:
                        self.log_message("警告: 无法动态修改FunASR的内部参数。可能需要直接修改FunASR.py。")

                threading.Thread(target=self._initial_model_load, daemon=True).start()
            except Exception as e:
                self.log_message(f"创建FunASR实例失败: {e}")
                self.asr_instance = None
        else:
            self.log_message("错误: FunASR 模块未找到，语音识别不可用。", True)


    def _initial_model_load(self):
        self.all_models_loaded = False # Reset status at the beginning of load attempt
        # Ensure button is disabled during this process, in case it was enabled before an error and retry
        self.root.after(0, lambda: self.start_stop_button.config(state="disabled"))

        if self.asr_instance:
            self.log_message("正在加载ASR主模型 (如果尚未加载)...")
            if not self.asr_instance.ensure_asr_model_loaded():
                self.log_message("ASR主模型加载失败。", True)
                # self.asr_instance = None # Or handle error appropriately
                return # Stop further model loading if main one fails

            self.log_message("ASR主模型已就绪或正在加载。") # ensure_asr_model_loaded blocks until loaded or failed

            if self.asr_instance.use_vad:
                self.log_message("正在加载VAD模型 (如果需要)...")
                if not self.asr_instance.load_vad_model_if_needed():
                    self.log_message("VAD模型加载失败。", True)
                else:
                    self.log_message("VAD模型已就绪或已加载。")

            if self.asr_instance.use_punc:
                self.log_message("正在加载标点模型 (如果需要)...")
                if not self.asr_instance.load_punc_model_if_needed():
                    self.log_message("标点模型加载失败。ASR将不带标点运行或无法运行。", True)
                    # Depending on severity, you might want to set all_models_loaded to False and return
                    # For now, we allow proceeding without punc if it fails but other models are OK.
                    # However, for critical models like ASR main, we do return.
                else:
                    self.log_message("标点模型已就绪或已加载。")

            # Check if all critical models are loaded
            # For this example, ASR main model is critical. VAD and Punc are optional enhancements.
            if self.asr_instance.asr_model: # asr_model is the main one
                self.all_models_loaded = True
                self.log_message("所有核心ASR模型已成功加载/验证。")
                self.root.after(0, lambda: self.start_stop_button.config(state="normal"))
                self.root.after(0, lambda: self.log_message("模型加载完毕，可以开始同传。", True))
            else:
                self.all_models_loaded = False # Ensure it's false if main ASR model failed
                self.log_message("ASR主模型加载失败，无法启动同传。", True)
                self.root.after(0, lambda: self.start_stop_button.config(state="disabled"))

        else:
            self.log_message("ASR实例未创建，无法加载模型。")
            self.all_models_loaded = False
            self.root.after(0, lambda: self.start_stop_button.config(state="disabled"))

    def log_message(self, message, is_status=True):
        print(message)
        self.root.after(0, self._update_log_area, message + "\n")
        if is_status:
             pass #保持这个状态，可以用来更新状态栏等

    def _update_log_area(self, message):
        self.log_text_area.config(state="normal")
        self.log_text_area.insert(tk.END, message)
        self.log_text_area.see(tk.END)
        self.log_text_area.config(state="disabled")

    def start_asyncio_loop(self):
        def loop_runner():
            self.async_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.async_loop)
            try:
                self.async_loop.run_forever()
            finally:
                self.async_loop.close()
        self.async_loop_thread = threading.Thread(target=loop_runner, daemon=True)
        self.async_loop_thread.start()
        self.log_message("Asyncio事件循环已启动。")

    def run_async_task(self, coro):
        if not self.async_loop or not self.async_loop.is_running():
            self.log_message("错误: Asyncio事件循环未运行。")
            # As a fallback, try starting it if it's not already starting/running
            if not hasattr(self, 'async_loop_thread') or not self.async_loop_thread.is_alive():
                self.log_message("尝试重新启动Asyncio事件循环...")
                self.start_asyncio_loop()
            # Give it a moment to start, then check again
            # This is a bit of a hack, robust applications might handle this more gracefully
            time.sleep(0.1)
            if not self.async_loop or not self.async_loop.is_running():
                self.log_message("错误: Asyncio事件循环仍未运行。异步任务无法执行。")
                return None
        return asyncio.run_coroutine_threadsafe(coro, self.async_loop)

    def populate_audio_devices(self):
        try:
            devices = sd.query_devices()
            input_devices = [(i, device['name']) for i, device in enumerate(devices) if device['max_input_channels'] > 0]
            output_devices = [(device['name'], device['name']) for device in devices if device['max_output_channels'] > 0] # Pygame uses name

            if input_devices:
                self.input_device_dropdown['values'] = [f"{name} (ID: {idx})" for idx, name in input_devices]
                # Try to set a default input device
                default_input_device = sd.default.device[0]
                for i, (idx, name) in enumerate(input_devices):
                    if idx == default_input_device:
                        self.input_device_var.set(self.input_device_dropdown['values'][i])
                        self.selected_input_device_idx = idx
                        break
                if not self.selected_input_device_idx and input_devices: # Fallback to first available
                    self.input_device_var.set(self.input_device_dropdown['values'][0])
                    self.selected_input_device_idx = input_devices[0][0]
            else:
                self.input_device_dropdown['values'] = ["无可用输入设备"]
                self.input_device_var.set("无可用输入设备")

            if output_devices:
                self.output_device_dropdown['values'] = [name for _, name in output_devices]
                 # Try to set a default output device for pygame (it's trickier as pygame doesn't list by index easily before init)
                # For now, we select the first one. User can change.
                # A more robust way would be to query pygame *after* a generic init, then re-init with selection.
                # Or, list devices known to sounddevice and hope pygame can use their names.
                self.output_device_var.set(output_devices[0][0])
                self.selected_output_device_name = output_devices[0][0]
                self.init_pygame_mixer() # Initialize with the default/first output device
            else:
                self.output_device_dropdown['values'] = ["无可用输出设备"]
                self.output_device_var.set("无可用输出设备")

        except Exception as e:
            self.log_message(f"加载音频设备失败: {e}")
            self.input_device_dropdown['values'] = ["错误"]
            self.input_device_var.set("错误")
            self.output_device_dropdown['values'] = ["错误"]
            self.output_device_var.set("错误")

    def on_input_device_selected(self, event):
        selection = self.input_device_var.get()
        if " (ID: " in selection and selection != "无可用输入设备":
            try:
                # Extract index from format "Device Name (ID: index)"
                self.selected_input_device_idx = int(selection.split(' (ID: ')[-1][:-1])
                self.log_message(f"选择输入设备 ID: {self.selected_input_device_idx}")
                # If ASR is running, it might need to be restarted to use the new device.
                # For now, we assume selection is done before starting.
            except ValueError:
                self.log_message(f"错误: 无法解析输入设备选择 '{selection}'")
                self.selected_input_device_idx = None # Fallback to default in ASR

    def on_output_device_selected(self, event):
        selection = self.output_device_var.get()
        if selection and selection != "无可用输出设备" and selection != "错误":
            self.selected_output_device_name = selection
            self.log_message(f"选择输出设备: {self.selected_output_device_name}")
            self.init_pygame_mixer() # Re-initialize mixer with the new device
        else:
            self.selected_output_device_name = None
            # Potentially uninitialize or set to a known safe state if mixer was initialized
            if self.mixer_initialized:
                pygame.mixer.quit()
                self.mixer_initialized = False
            self.log_message("未选择有效输出设备，TTS播放可能失败。")

    def init_pygame_mixer(self):
        if self.mixer_initialized:
            pygame.mixer.quit()
            self.mixer_initialized = False
            # self.mixer_output_device_name = None # Reset when quitting previous instance

        current_selected_device_name_str = self.selected_output_device_name
        if isinstance(current_selected_device_name_str, bytes):
            # Ensure it's a string if it came as bytes from somewhere unexpectedly
            try:
                current_selected_device_name_str = current_selected_device_name_str.decode('utf-8')
            except UnicodeDecodeError:
                self.log_message(f"警告: 输出设备名称无法解码为UTF-8: {current_selected_device_name_str}", True)
                current_selected_device_name_str = None # Fallback to default

        try:
            if current_selected_device_name_str:
                self.log_message(f"正在初始化Pygame Mixer，使用设备: {current_selected_device_name_str}...")
                pygame.mixer.init(devicename=current_selected_device_name_str)
                self.mixer_output_device_name = current_selected_device_name_str # Store the successfully used device name
            else:
                self.log_message("正在使用默认设备初始化Pygame Mixer...")
                pygame.mixer.init() # Initialize with default device
                self.mixer_output_device_name = None # Indicate default device was used
            self.mixer_initialized = True
            self.log_message("Pygame Mixer 初始化成功。")
            return True # Added return True for success
        except Exception as e:
            self.log_message(f"Pygame Mixer 初始化失败 (设备: {current_selected_device_name_str}): {e}")
            self.mixer_initialized = False
            self.mixer_output_device_name = None # Reset on failure
            # Fallback to default device if specific one failed
            if current_selected_device_name_str is not None: # Check if we tried a specific device
                self.log_message("尝试使用默认设备再次初始化 Pygame Mixer...")
                try:
                    pygame.mixer.init() # Default device
                    self.mixer_initialized = True
                    self.mixer_output_device_name = None # Indicate default device was used
                    self.log_message("Pygame Mixer 已使用默认设备成功初始化。")
                    return True # Added return True for success
                except Exception as e_default:
                    self.log_message(f"使用默认设备初始化 Pygame Mixer 仍失败: {e_default}")
            return False # Added return False for failure

    def _update_rate_label(self, value):
        self.tts_rate_label_var.set(f"{int(float(value)):+d}%")

    def _update_volume_label(self, value):
        self.tts_volume_label_var.set(f"{int(float(value)):+d}%") # Ensure + sign for positive values

    def populate_unified_target_languages(self):
        self.log_message("正在加载统一的目标语言列表...")
        if COMBINED_SUPPORTED_LANGUAGES:
            self.target_lang_dropdown['values'] = [lang['display_name'] for lang in COMBINED_SUPPORTED_LANGUAGES]
            if self.target_lang_dropdown['values']:
                self.target_lang_dropdown.current(0)
                # Trigger the selection callback to populate gender and voice
                self.on_target_language_selected(None)
            else:
                self.log_message("错误: 共同支持的语言列表为空。", True)
                self.target_lang_dropdown['values'] = []
                self.gender_dropdown['values'] = []
                self.tts_voice_dropdown['values'] = []
                self.start_stop_button.config(state="disabled")
        else:
            self.log_message("错误: 未找到任何可用的目标语言 (COMBINED_SUPPORTED_LANGUAGES为空)。", True)
            self.target_lang_dropdown['values'] = []
            self.gender_dropdown['values'] = []
            self.tts_voice_dropdown['values'] = []
            self.start_stop_button.config(state="disabled")

    async def _fetch_voices_async(self, lang_code_for_tts):
        # This function is no longer needed as we use the static SUPPORTED_TTS_VOICES list.
        # Kept for reference during refactoring, will be removed.
        pass

    def on_target_language_selected(self, event):
        selected_lang_display_name = self.target_lang_var.get()
        self.gender_dropdown['values'] = [] # Clear previous gender options
        self.gender_var.set('')
        self.tts_voice_dropdown['values'] = [] # Clear previous voice options
        self.tts_voice_var.set('')

        if not selected_lang_display_name or not SUPPORTED_TTS_VOICES:
            if not SUPPORTED_TTS_VOICES:
                self.log_message("TTS语音列表未加载，无法选择性别和音色。", True)
            return

        voices_for_lang = [
            v for v in SUPPORTED_TTS_VOICES if v["language_display"].startswith(selected_lang_display_name)
        ]

        if not voices_for_lang:
            self.log_message(f"警告: 无法为 '{selected_lang_display_name}' 找到匹配的TTS语音。", True)
            return

        available_genders = sorted(list(set(v["gender_display"] for v in voices_for_lang)))
        self.gender_dropdown['values'] = available_genders
        if available_genders:
            self.gender_dropdown.current(0)
            self.on_gender_selected(None) # Trigger gender selection to populate voices
        else:
            self.log_message(f"未找到 '{selected_lang_display_name}' 的可用性别。", True)

    def on_gender_selected(self, event):
        selected_lang_display_name = self.target_lang_var.get()
        selected_gender = self.gender_var.get()

        self.tts_voice_dropdown['values'] = [] # Clear previous voice options
        self.tts_voice_var.set('')

        if not selected_lang_display_name or not selected_gender or not SUPPORTED_TTS_VOICES:
            return

        voices_for_selection = [
            v for v in SUPPORTED_TTS_VOICES
            if v["language_display"].startswith(selected_lang_display_name) and v["gender_display"] == selected_gender
        ]

        if not voices_for_selection:
            self.log_message(f"警告: 无法为 '{selected_lang_display_name} - {selected_gender}' 找到匹配的TTS音色。", True)
            return

        voice_display_list = []
        self.tts_voice_dropdown_map = {} # Reset and rebuild map

        for voice_info in sorted(voices_for_selection, key=lambda x: (x.get('locale_display', ''), x.get('voice_display', ''))):
            display_name = f"{voice_info.get('locale_display', 'N/A')} - {voice_info.get('voice_display', 'N/A')}"
            voice_display_list.append(display_name)
            self.tts_voice_dropdown_map[display_name] = voice_info['short_name']

        self.tts_voice_dropdown['values'] = voice_display_list
        if voice_display_list:
            self.tts_voice_dropdown.current(0)
            # Automatically set tts_voice_var to the short_name of the initially selected voice
            first_voice_display_name = voice_display_list[0]
            if first_voice_display_name in self.tts_voice_dropdown_map:
                 self.tts_voice_var.set(self.tts_voice_dropdown_map[first_voice_display_name])
            else:
                # Fallback or error, though this path should ideally not be hit if map is built correctly
                self.tts_voice_var.set('')
                self.log_message(f"错误: 初始化音色时, '{first_voice_display_name}' 未在映射中找到。", True)
        else:
            self.log_message(f"未找到 '{selected_lang_display_name} - {selected_gender}' 的可用音色。", True)

    def on_tts_voice_selected(self, event): # This callback is bound to <<ComboboxSelected>>
        selected_display_name = self.tts_voice_dropdown.get() # This gets the selected display string from combobox
        if selected_display_name in self.tts_voice_dropdown_map:
            self.tts_voice_var.set(self.tts_voice_dropdown_map[selected_display_name])
            # self.log_message(f"音色已选择: {selected_display_name} -> {self.tts_voice_var.get()}") # Optional: for debugging
        else:
            self.tts_voice_var.set('') # Clear if no valid mapping
            self.log_message(f"错误: 选择的音色 '{selected_display_name}' 没有找到对应的 short_name。映射表项: {list(self.tts_voice_dropdown_map.keys())}", True)

    def toggle_translation(self):
        if self.is_running:
            self.stop_translation_process()
        else:
            self.start_translation_process()

    def start_translation_process(self):
        if not self.all_models_loaded:
            self.log_message("错误：模型尚未完全加载，请稍候或检查日志。", True)
            self.start_stop_button.config(text="开始同传") # Reset button text
            self.is_running = False
            # Optionally, try to trigger a reload if it failed previously and not currently loading
            # For now, just inform the user.
            return

        if not self.asr_instance: # Check if ASR instance was created
            self.log_message("错误：FunASR实例未初始化，无法开始。", True)
            self.start_stop_button.config(text="开始同传") # Reset button text
            self.is_running = False
            if FastLoadASR and not self.asr_instance: # Check if class exists but instance is None
                self.log_message("尝试重新初始化 FunASR 实例...")
                self.all_models_loaded = False # Mark models as not loaded before re-init
                self.start_stop_button.config(state="disabled") # Disable button during re-load
                try:
                    self.asr_instance = FastLoadASR(
                        use_vad=True,
                        use_punc=True,
                        text_output_callback=self.asr_text_callback,
                        input_device_index=self.selected_input_device_idx # 使用选择的输入设备
                    )
                    if self.asr_instance: # 确保实例存在
                        self._apply_asr_settings_to_instance() # Apply current ASR settings

                    # Start model loading in a separate thread as it can be blocking
                    threading.Thread(target=self._initial_model_load, daemon=True).start()
                    self.log_message("FunASR 实例已重新初始化，正在加载模型...") # 保留此日志
                except Exception as e:
                    self.log_message(f"重新创建FunASR实例失败: {e}")
                    self.all_models_loaded = False # Ensure flag is false on failure
                    self.start_stop_button.config(state="disabled") # Keep disabled
                    self.is_running = False # Ensure is_running is also false
                    return # Exit if re-initialization fails
            else:
                 self.is_running = False # Ensure is_running is also false
                 return # Exit if FastLoadASR not available or instance still None


        if not self.selected_input_device_idx:
            self.log_message("错误：未选择输入设备。", True)
            self.start_stop_button.config(text="开始同传")
            self.is_running = False
            return

        if not self.selected_output_device_name:
            self.log_message("错误：未选择输出设备。", True)
            self.start_stop_button.config(text="开始同传")
            self.is_running = False
            return

        # Initialize Pygame Mixer with the selected output device
        # This check ensures that init_pygame_mixer is called if not initialized OR if the device changed.
        if not self.mixer_initialized or (self.selected_output_device_name != self.mixer_output_device_name):
            if not self.init_pygame_mixer(): # Call and check return value
                self.log_message(f"错误: 初始化Pygame Mixer失败，无法播放音频。设备: {self.selected_output_device_name}", True)
                self.start_stop_button.config(text="开始同传")
                self.is_running = False
                return
            # self.mixer_output_device_name is set within init_pygame_mixer upon success


        selected_target_lang_display = self.target_lang_var.get()
        selected_tts_voice_short_name = self.tts_voice_var.get() # This should now be the short_name

        if not selected_target_lang_display:
            self.log_message("错误: 未选择目标语言。", True)
            # self.start_stop_button.config(text="开始同传") # Redundant, keep is_running logic
            # self.is_running = False
            return

        target_lang_info = next((lang for lang in COMBINED_SUPPORTED_LANGUAGES if lang['display_name'] == selected_target_lang_display), None)
        if not target_lang_info:
            self.log_message(f"错误: 无法找到目标语言 '{selected_target_lang_display}' 的翻译代码。", True)
            # self.is_running = False
            return

        self.current_target_lang_code = target_lang_info['translation_code']

        if not selected_tts_voice_short_name and edge_TTS: # Check edge_TTS to avoid error if module is missing
            self.log_message("警告: 未选择TTS音色。将仅进行文本翻译。", True)
            self.current_tts_voice = None
        elif edge_TTS:
             self.current_tts_voice = selected_tts_voice_short_name
        else:
            self.current_tts_voice = None


        if not self.translation_instance:
            self.log_message("错误：翻译模块未初始化（请检查API密钥），无法开始。", True)
            return
        if not edge_TTS:
            self.log_message("错误：edge_TTS模块未加载，无法开始。", True)
            return
        if not self.target_lang_var.get() or self.target_lang_var.get() == "N/A" or not self.tts_voice_var.get():
            self.log_message("错误：请选择有效的目标语言和音色。", True)
            return

        # Ensure models are loaded before starting session (if not already by _initial_model_load)
        # This check might be redundant if _initial_model_load is guaranteed to finish and succeed.
        # However, it's a safeguard.
        if not self.asr_instance.asr_model: # Check if the main ASR model is loaded
            self.log_message("ASR主模型尚未加载完成，请稍候...", True)
            # Optionally, could try to trigger load again or just wait.
            # For now, we assume _initial_model_load handles this.
            # A more robust way would be to disable start button until models are ready.
            if not self.asr_instance.ensure_asr_model_loaded(): # blocking call
                 self.log_message("ASR主模型加载失败，无法启动。", True)
                 return


        self.is_running = True
        self.start_stop_button.config(text="停止同传")
        self.log_message("正在启动同声传译服务...", True)

        self._update_text_area(self.recognized_text_area, "", clear_all=True)
        self._update_text_area(self.translated_text_area, "", clear_all=True)
        self.current_recognized_sentence = ""
        self.last_final_asr_text = ""
        self.recognized_text_has_interim = False

        # Reset and start ASR activity timer
        self.last_asr_activity_time = time.time() # Initialize/reset activity time
        if self.asr_timeout_check_timer_id:
            self.root.after_cancel(self.asr_timeout_check_timer_id)
            self.asr_timeout_check_timer_id = None
        self._check_asr_activity_timeout() # Start the timeout check loop

        # Start ASR instance (this should reset its internal state, not reload models)
        try:
            # FunASR's start method should handle starting the recording and processing threads.
            # It should also reset internal states like buffers and caches.
            threading.Thread(target=self.asr_instance.start, daemon=True).start()
            self.log_message("同声传译已启动。 FunASR正在聆听...", True)
        except Exception as e:
            self.log_message(f"启动FunASR失败: {e}", True)
            self.is_running = False
            self.start_stop_button.config(text="开始同传")
            return

        # Start worker threads for translation and TTS
        threading.Thread(target=self.translation_worker, daemon=True).start()
        threading.Thread(target=self.tts_worker, daemon=True).start()

    def stop_translation_process(self):
        self.log_message("正在停止同声传译服务...", True)
        if self.asr_instance and self.is_running:
            try:
                self.asr_instance.stop() # This should stop recording and processing in FunASR
            except Exception as e:
                self.log_message(f"停止FunASR时出错: {e}")

        self.is_running = False # Set to false to signal worker threads to stop
        # Stop ASR activity timeout check BEFORE changing button text and logging stop, to ensure it's cleanly handled
        if self.asr_timeout_check_timer_id:
            self.root.after_cancel(self.asr_timeout_check_timer_id)
            self.asr_timeout_check_timer_id = None
            self.log_message("ASR活动超时检查已停止。")

        self.start_stop_button.config(text="开始同传")

        # Clear queues after stopping ASR and setting is_running to false
        self.root.after(100, self._clear_queues)
        self.log_message("同声传译已停止。", True)

    def _clear_queues(self):
        for q in [self.asr_output_queue, self.translation_output_queue]:
            while not q.empty():
                try: q.get_nowait()
                except queue.Empty: break
        self.log_message("处理队列已清空。")

    def asr_text_callback(self, recognized_segment, current_full_sentence, is_sentence_end):
        if not self.is_running: return
        self.last_asr_activity_time = time.time() # Update activity time

        if is_sentence_end:
            final_text = current_full_sentence.strip()
            if final_text and final_text != self.last_final_asr_text:
                self.log_message(f"ASR (Final): {final_text}")
                self.last_final_asr_text = final_text
                self.raw_text_of_last_forced_sentence = None # Clear this as ASR provided a proper end
                update_mode = 'replace_interim_with_final' if self.recognized_text_has_interim else 'append_final'
                self.root.after(0, lambda: self._update_text_area(self.recognized_text_area, final_text + "\n", mode=update_mode))
                self.asr_output_queue.put(final_text)
                self.recognized_text_has_interim = False
            elif not final_text:
                 self.log_message(f"ASR (Final Empty Ignored)")
                 if self.recognized_text_has_interim:
                    self.root.after(0, lambda: self._update_text_area(self.recognized_text_area, "", mode='clear_interim'))
                 self.recognized_text_has_interim = False
            else:
                self.log_message(f"ASR (Duplicate Final Ignored): {final_text}")
            self.current_recognized_sentence = ""
        else:
            # Handle interim results more carefully
            current_full_sentence_from_asr = current_full_sentence # Keep original for clarity

            prefix_to_check_against = None
            if self.raw_text_of_last_forced_sentence:
                prefix_to_check_against = self.raw_text_of_last_forced_sentence
            elif self.last_final_asr_text: # If no raw forced text, use the last final text (which might have punc)
                # Basic attempt to strip common sentence-ending punctuation for comparison
                # This is a heuristic and might not be perfect.
                stripped_last_final = self.last_final_asr_text.strip()
                if stripped_last_final.endswith(('.', '。', '?', '？', '!', '！')):
                    stripped_last_final = stripped_last_final[:-1]
                prefix_to_check_against = stripped_last_final.strip()

            if prefix_to_check_against and current_full_sentence_from_asr.startswith(prefix_to_check_against):
                potential_new_segment = current_full_sentence_from_asr[len(prefix_to_check_against):].lstrip()
                if potential_new_segment:
                    # self.current_recognized_sentence = prefix_to_check_against + " " + potential_new_segment
                    # Let's make self.current_recognized_sentence represent the full line as ASR sees it for now.
                    # The UI update logic in _update_text_area for 'update_interim' should handle replacing the line.
                    self.current_recognized_sentence = current_full_sentence_from_asr
                else:
                    if recognized_segment:
                         self.log_message(f"ASR (Interim segment, but no new full sentence change from prefix): {recognized_segment}")
                    return
            else:
                 self.current_recognized_sentence = current_full_sentence_from_asr

            self.log_message(f"ASR (Interim Update): {self.current_recognized_sentence} (Segment: {recognized_segment})")
            self.root.after(0, lambda: self._update_text_area(self.recognized_text_area, self.current_recognized_sentence, mode='update_interim'))
            self.recognized_text_has_interim = True
            # Do not schedule a new timeout check here, it's handled by start_translation_process

    def _force_finalize_current_sentence(self):
        if not self.is_running or not self.current_recognized_sentence: # Extra check
            return

        final_text_unpunc = self.current_recognized_sentence.strip()
        self.raw_text_of_last_forced_sentence = final_text_unpunc # Store the raw text before punctuation
        final_text = final_text_unpunc # Default to unpunctuated

        # Attempt to apply punctuation if model is available
        if self.asr_instance and hasattr(self.asr_instance, 'punc_model') and self.asr_instance.punc_model and \
           hasattr(self.asr_instance, 'use_punc') and self.asr_instance.use_punc and final_text_unpunc:
            try:
                self.log_message(f"Attempting to punctuate forced-final text: {final_text_unpunc}")
                punc_res = self.asr_instance.punc_model.generate(final_text_unpunc)
                # FunASR punc model typically returns a list of dicts, e.g., [{'text': 'punctuated text'}]
                if punc_res and isinstance(punc_res, list) and len(punc_res) > 0 and 'text' in punc_res[0]:
                    final_text = punc_res[0]['text']
                    self.log_message(f"Punctuation applied to forced-final: {final_text}")
                else:
                    self.log_message(f"Punctuation model returned unexpected result for '{final_text_unpunc}'. Using unpunctuated.")
            except Exception as e:
                self.log_message(f"Error applying punctuation to forced-final text '{final_text_unpunc}': {e}. Using unpunctuated.")

        self.log_message(f"ASR (Forced Final due to timeout): {final_text}")

        # Similar logic to normal finalization in asr_text_callback
        if final_text and final_text != self.last_final_asr_text:
            self.last_final_asr_text = final_text
            update_mode = 'replace_interim_with_final' if self.recognized_text_has_interim else 'append_final'
            self.root.after(0, lambda: self._update_text_area(self.recognized_text_area, final_text + "\n", mode=update_mode))
            self.asr_output_queue.put(final_text)
        elif not final_text and self.recognized_text_has_interim: # Handle case where interim was there but final is empty
            self.root.after(0, lambda: self._update_text_area(self.recognized_text_area, "", mode='clear_interim'))

        self.current_recognized_sentence = "" # Crucial: clear current sentence
        self.recognized_text_has_interim = False
        self.last_asr_activity_time = None # Reset to prevent immediate re-trigger if no new audio

    def _check_asr_activity_timeout(self):
        if not self.is_running: # Stop if service is stopped
            if self.asr_timeout_check_timer_id:
                self.root.after_cancel(self.asr_timeout_check_timer_id)
                self.asr_timeout_check_timer_id = None
            return

        if self.current_recognized_sentence and self.last_asr_activity_time:
            if (time.time() - self.last_asr_activity_time) > self.force_sentence_end_timeout:
                self.log_message("ASR activity timeout detected. Forcing sentence finalization.")
                self._force_finalize_current_sentence()

        # Reschedule the check
        if self.is_running: # Only reschedule if still running
             self.asr_timeout_check_timer_id = self.root.after(200, self._check_asr_activity_timeout) # Check every 200ms

    def translation_worker(self):
        while True:
            try:
                source_text = self.asr_output_queue.get(timeout=0.5)
                if not self.is_running and self.asr_output_queue.empty(): break
                if not source_text or not self.translation_instance:
                    if not self.is_running: break
                    continue
                from_lang_code = "cn"
                target_lang_name = self.target_lang_var.get()
                to_lang_code = LANGUAGE_CODES.get(target_lang_name)
                if not to_lang_code:
                    self.log_message(f"翻译错误：无效目标语言 {target_lang_name}")
                    if not self.is_running: break
                    continue
                self.log_message(f"开始翻译: {source_text[:30]}... -> {to_lang_code}")
                try:
                    translated_text = self.translation_instance.translate(
                        text=source_text,
                        from_lang=from_lang_code,
                        to_lang=to_lang_code
                    )
                    if translated_text:
                        self.log_message(f"翻译完成: {translated_text[:30]}...")
                        self.translation_output_queue.put(translated_text)
                        self.root.after(0, lambda t=translated_text: self._update_text_area(self.translated_text_area, t + "\n", mode='append_final'))
                    else:
                        self.log_message(f"翻译结果为空 for: {source_text[:30]}")
                except Exception as e:
                    self.log_message(f"翻译API调用失败: {e}")
                self.asr_output_queue.task_done()
            except queue.Empty:
                if not self.is_running: break
                continue
            except Exception as e:
                self.log_message(f"翻译线程异常: {e}")
                if not self.is_running: break
                time.sleep(0.1)
        self.log_message("翻译线程已停止。")

    def tts_worker(self):
        while True:
            try:
                translated_text = self.translation_output_queue.get(timeout=0.5)
                if not self.is_running and self.translation_output_queue.empty(): break
                if not translated_text or not edge_TTS:
                    if not self.is_running: break
                    continue
                selected_voice = self.tts_voice_var.get()
                if not selected_voice:
                    self.log_message("TTS错误: 未选择音色。语音无法合成。")
                    if not self.is_running: break
                    continue

                # Get rate and volume from scales
                rate_val = int(self.tts_rate_var.get())
                volume_val = int(self.tts_volume_var.get())

                rate_str = f"{rate_val:+d}%"
                volume_str = f"{volume_val:+d}%"

                self.log_message(f"开始语音合成: {translated_text[:30]}... (音色: {selected_voice}, 语速: {rate_str}, 音量: {volume_str})")
                future = self.run_async_task(
                    edge_TTS.text_to_speech(translated_text, selected_voice, rate=rate_str, volume=volume_str)
                )
                if future:
                    try:
                        success = future.result(timeout=30)
                        if success:
                            self.log_message(f"语音播放成功: {translated_text[:30]}...")
                        else:
                             self.log_message(f"语音合成或播放失败: {translated_text[:30]}")
                    except asyncio.TimeoutError:
                        self.log_message(f"TTS任务超时: {translated_text[:30]}")
                    except Exception as e:
                        self.log_message(f"TTS播放时发生错误: {e}")
                else:
                    self.log_message("无法调度TTS任务进行播放。")
                self.translation_output_queue.task_done()
            except queue.Empty:
                if not self.is_running: break
                continue
            except Exception as e:
                self.log_message(f"TTS线程异常: {e}")
                if not self.is_running: break
                time.sleep(0.1)
        self.log_message("TTS线程已停止。")

    def _update_text_area(self, area, text, mode='append_final', clear_all=False):
        area.config(state="normal")
        if clear_all:
            area.delete(1.0, tk.END)
        elif mode == 'append_final':
            area.insert(tk.END, text)
        elif mode == 'update_interim':
            current_content = area.get(1.0, tk.END).rstrip('\n')
            last_newline_idx = current_content.rfind('\n')
            if not self.recognized_text_has_interim:
                if current_content and not current_content.endswith('\n'):
                    area.insert(tk.END, "\n")
                area.insert(tk.END, text)
            elif last_newline_idx == -1:
                area.delete(1.0, tk.END)
                area.insert(1.0, text)
            else:
                area.delete(f"1.0 + {last_newline_idx + 1}c", tk.END)
                area.insert(tk.END, text)
        elif mode == 'replace_interim_with_final':
            current_content = area.get(1.0, tk.END).rstrip('\n')
            last_newline_idx = current_content.rfind('\n')
            if last_newline_idx == -1:
                area.delete(1.0, tk.END)
            else:
                area.delete(f"1.0 + {last_newline_idx + 1}c", tk.END)
            current_content_after_delete = area.get(1.0, tk.END).rstrip('\n')
            if current_content_after_delete and not current_content_after_delete.endswith('\n'):
                 area.insert(tk.END, "\n")
            area.insert(tk.END, text)
        elif mode == 'clear_interim':
            current_content = area.get(1.0, tk.END).rstrip('\n')
            last_newline_idx = current_content.rfind('\n')
            if self.recognized_text_has_interim:
                if last_newline_idx == -1:
                    area.delete(1.0, tk.END)
                else:
                    area.delete(f"1.0 + {last_newline_idx + 1}c", tk.END)
        area.see(tk.END)
        area.config(state="disabled")

    def process_ui_updates(self):
        self.root.after(200, self.process_ui_updates)

    def on_closing(self):
        self.log_message("应用正在关闭...", True)
        self.stop_translation_process()

        if self.mixer_initialized: # 确保在关闭前退出mixer
            self.log_message("正在关闭 Pygame Mixer...")
            pygame.mixer.quit()
            self.mixer_initialized = False
            self.log_message("Pygame Mixer 已关闭。")

        if self.async_loop and self.async_loop.is_running():
            self.log_message("正在停止Asyncio事件循环...")
            self.async_loop.call_soon_threadsafe(self.async_loop.stop)
        if self.async_loop_thread and self.async_loop_thread.is_alive():
            self.log_message("等待Asyncio线程结束...")
            self.async_loop_thread.join(timeout=2)
            if self.async_loop_thread.is_alive():
                self.log_message("警告: Asyncio线程超时未结束。", True)
            else:
                self.log_message("Asyncio线程已停止。")
        self.log_message("正在销毁UI...")
        self.root.destroy()
        print("应用已关闭。")

    def _update_asr_duration_label(self, value_str):
        try:
            val = float(value_str)
            self.asr_silence_duration_label_var.set(f"{val:.2f}s")
            self._apply_asr_settings_to_instance()
        except ValueError:
            pass # Ignore if value is not a float yet (can happen during slider drag)

    def _update_asr_relative_vol_label(self, value_str):
        try:
            val = float(value_str)
            self.asr_relative_silence_label_var.set(f"{val:.2f}")
            self._apply_asr_settings_to_instance()
        except ValueError:
            pass # Ignore

    def _apply_asr_settings_to_instance(self):
        if self.asr_instance and self.is_running: # Apply only if ASR is active
            try:
                duration = self.asr_silence_duration_var.get()
                relative_vol = self.asr_relative_silence_var.get()
                self.asr_instance.silence_duration_threshold = duration
                self.asr_instance.relative_silence_threshold = relative_vol
                # Log less frequently to avoid spamming, perhaps only on significant changes or after a delay
                # For now, we log every time for debugging.
                self.log_message(f"实时更新FunASR参数: Duration={duration:.2f}s, RelativeVol={relative_vol:.2f}")
            except AttributeError:
                self.log_message("警告: 无法动态修改FunASR的内部参数 (实时更新失败)。")
            except Exception as e:
                self.log_message(f"实时更新FunASR参数时出错: {e}")
        elif self.asr_instance and not self.is_running:
             # Store for next run, or simply let the init/start_translation_process handle it.
             # For now, we do nothing if not running, as init/start will pick up current UI values.
             pass

if __name__ == '__main__':
    root = tk.Tk()
    app = SimultaneousTranslatorApp(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    try:
        root.mainloop()
    except KeyboardInterrupt:
        print("用户通过Ctrl+C中断mainloop。")
        app.on_closing()